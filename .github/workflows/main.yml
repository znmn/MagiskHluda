name: CI
on:
  workflow_dispatch:
    inputs:
      version:
        description: "Specific Florida version to build (e.g. 17.6.2). Leave empty to auto-detect latest."
        required: false
        default: ""
        type: string
  schedule:
    - cron: "0 */12 * * *"
permissions:
  contents: write
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Fetch release info
        run: |
          sudo apt install jq
          # If a manual version is provided, use it directly; otherwise auto-detect
          if [ -n "${{ github.event.inputs.version }}" ]; then
            LATESTFLORIDARELEASETAG="${{ github.event.inputs.version }}"
            echo "Manual version specified: ${LATESTFLORIDARELEASETAG}"
          else
            LATESTFLORIDARELEASETAG=$(curl -s https://api.github.com/repos/Ylarod/Florida/releases | jq -r '[.[] | select(.assets | length > 0)][0].tag_name')
            echo "Auto-detected version: ${LATESTFLORIDARELEASETAG}"
          fi
          LATESTMODULETAG=$(curl -s https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest | jq -r '.tag_name')
          echo "LATESTFLORIDARELEASETAG=${LATESTFLORIDARELEASETAG}" >> $GITHUB_ENV
          echo "LATESTMODULETAG=${LATESTMODULETAG}" >> $GITHUB_ENV
          echo "MANUAL_VERSION=${{ github.event.inputs.version }}" >> $GITHUB_ENV
      - name: Check if release needed
        id: check_release
        run: |
          # If manual version is provided, always release (force build)
          if [ -n "${{ env.MANUAL_VERSION }}" ]; then
            echo "Manual version provided, forcing release"
            echo "should_release=true" >> $GITHUB_OUTPUT
          elif [ "${{ env.LATESTFLORIDARELEASETAG }}" != "${{ env.LATESTMODULETAG }}" ] && \
               [ "${{ env.LATESTFLORIDARELEASETAG }}" != "null" ] && \
               [ "${{ env.LATESTMODULETAG }}" != "null" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
          fi
      - name: Cache vcpkg packages
        if: steps.check_release.outputs.should_release == 'true'
        uses: actions/cache@v3
        with:
          path: |
            vcpkg
            ~/vcpkg/installed
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json', '**/vcpkg-configuration.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-
      - name: Setup vcpkg if not cached
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          if [ ! -d "vcpkg" ]; then
            git clone https://github.com/Microsoft/vcpkg.git
            cd vcpkg
            ./bootstrap-vcpkg.sh
            ./vcpkg install rapidjson restclient-cpp
            cd ..
          fi
      - name: Build MagiskHluda
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE=vcpkg/scripts/buildsystems/vcpkg.cmake
          cmake --build build --config Release
          cp build/MagiskHluda .
      - name: Download all Florida servers from ylarod's repo
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          if [ -n "${{ env.MANUAL_VERSION }}" ]; then
            ./MagiskHluda "${{ env.MANUAL_VERSION }}"
          else
            ./MagiskHluda
          fi

      - name: Set up Node.js
        if: steps.check_release.outputs.should_release == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: "18"
      - name: Bundle webpage with Vite
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          # Check if webroot directory exists
          if [ ! -d "webroot" ]; then
            echo "Error: webroot directory not found in the repository"
            exit 1
          fi

          # Create webroot directory in module_template if it doesn't exist
          mkdir -p module_template/webroot

          # Run Vite build directly with npx
          cd webroot
          npm i
          npx vite build

      - name: Prepare release archives
        if: steps.check_release.outputs.should_release == 'true'
        run: |
          for arch in arm arm64 x86 x86_64; do
            FILENAME="florida-$([[ "$arch" == "x86_64" ]] && echo "x64" || echo "$arch").gz"
            mkdir -p "arch_release_$arch/bin"
            cp -r module_template/* "arch_release_$arch/"
            cp "bin/$FILENAME" "arch_release_$arch/bin/"
            (cd "arch_release_$arch" && zip -r "../Magisk-Florida-$arch-$LATESTFLORIDARELEASETAG.zip" .)
          done

          # Universal package
          mkdir -p universal_release
          cp -r module_template/* universal_release/
          mkdir -p "universal_release/bin"
          cp -r bin/* universal_release/bin/
          (cd universal_release && zip -r "../Magisk-Florida-Universal-$LATESTFLORIDARELEASETAG.zip" .)
      - name: Release Packages
        if: steps.check_release.outputs.should_release == 'true'
        uses: ncipollo/release-action@v1.13.0
        with:
          artifacts: |
            ./*.zip
            update.json
          name: "Magisk Module for Florida Server ${{ env.LATESTFLORIDARELEASETAG }}"
          tag: "${{ env.LATESTFLORIDARELEASETAG }}"
          body: "Universal package and architecture-specific packages for Florida Server ${{env.LATESTFLORIDARELEASETAG}}"
          generateReleaseNotes: false
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Upload ZIPs as workflow artifacts
        if: steps.check_release.outputs.should_release == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: Magisk-Florida-${{ env.LATESTFLORIDARELEASETAG }}
          path: |
            ./*.zip
            update.json
          if-no-files-found: error
          retention-days: 30
